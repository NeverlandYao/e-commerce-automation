# 电商AI自动化平台 - 整体规划文档

## 📋 项目概述

**项目名称**: E-Commerce AI Automation Platform  
**项目类型**: PC桌面客户端应用  
**核心流程**: 数据采集 → AI分析爆品 → 1688比价 → 自动上品  
**技术栈**: TypeScript + Rust + Tauri 2.0 + Crawlee + Playwright + FastGPT API + 插件化架构  
**目标**: 实现电商商品从发现到上架的全自动化流程的PC端桌面应用

## 🏗️ PC客户端系统架构设计

### 技术架构选型

**前端技术栈**:
- **Tauri 2.0**: 现代化跨平台桌面应用框架，基于Rust构建，支持Windows/macOS/Linux
- **React 18**: 现代化UI框架，组件化开发
- **shadcn/ui**: 现代化UI组件库，基于Radix UI和Tailwind CSS构建
- **TypeScript**: 类型安全，提升开发效率和代码质量
- **Vite**: 快速构建工具，支持热更新

**前端技术栈专注渲染**:
- **React Router**: 前端路由管理，页面导航
- **shadcn/ui**: 现代化UI组件库，基于Radix UI和Tailwind CSS构建，提供可复用的组件
- **Zustand**: 轻量级状态管理，管理UI状态和侧车进程通信状态
- **React Query**: 数据获取和缓存，与侧车进程API通信
- **Echarts/D3.js**: 数据可视化，展示分析结果和统计图表

**后端技术栈专注调度**:
- **Rust**: 高性能系统编程语言，专注进程管理和系统调度
- **Tauri Core**: 提供系统API、窗口管理和侧车进程生命周期管理
- **Tokio**: 异步运行时，处理侧车进程调度和监控
- **SQLite**: 轻量级本地数据库，存储任务队列和执行记录
- **进程调度器**: 负责侧车进程的启动、停止、重启和资源分配
- **任务队列**: 管理爬虫任务的分发和执行状态跟踪

**架构特点**:
- **本地优先**: 数据存储在本地，保护用户隐私
- **离线可用**: 核心功能支持离线使用
- **跨平台**: 一套代码支持多个操作系统
- **插件化**: 模块化设计，易于扩展
- **高性能**: Rust后端提供极致性能，内存安全
- **轻量级**: 相比Electron更小的安装包和更低的内存占用
- **安全性**: Rust的内存安全特性和Tauri的安全沙箱机制

### Tauri 2.0架构设计

**前端 (Frontend)**:
- React + TypeScript构建的现代化Web界面
- Vite作为构建工具，提供快速热重载
- shadcn/ui组件库，提供现代化的UI组件
- 状态管理使用Zustand，轻量级且类型安全
- 通过Tauri API与后端通信

**前端 (Frontend) 专注渲染**:
- React + TypeScript构建的现代化Web界面
- Vite作为构建工具，提供快速热重载
- shadcn/ui组件库，提供现代化的UI组件
- 状态管理使用Zustand，管理UI状态和侧车进程通信状态
- **任务管理界面**: 创建、配置和监控爬虫任务
- **数据展示界面**: 展示爬虫结果、分析报告和统计图表
- **插件管理界面**: 管理侧车进程中的插件配置
- **系统监控界面**: 实时显示侧车进程状态和资源使用情况
- 通过Tauri API与后端调度器通信，通过HTTP API与侧车进程通信

**后端 (Rust Core) 专注调度**:
- Rust编写的高性能调度核心
- Tauri Core提供窗口管理和系统API
- Tokio异步运行时处理侧车进程调度和监控
- 数据库操作和文件系统管理
- **侧车进程管理**: 启动、停止、重启和监控侧车进程
- **任务队列管理**: 管理爬虫任务的分发和执行状态
- **资源监控**: 监控侧车进程的CPU、内存和网络使用情况
- **故障恢复**: 检测侧车进程异常并自动重启
- **负载均衡**: 在多个侧车进程实例间分配任务

**命令系统 (Tauri Commands)**:
- 类型安全的前后端通信接口
- 异步命令处理，支持长时间运行的任务
- 事件系统用于实时状态更新
- 错误处理和结果返回
- 权限控制和安全验证

### 数据存储架构

**本地数据库 (SQLite)**:
- 商品数据存储
- 任务执行记录
- 用户配置信息
- 分析结果缓存

**文件系统存储**:
- 商品图片缓存
- 日志文件
- 插件配置
- 临时数据

**数据同步机制**:
- 本地数据备份
- 配置导入导出
- 数据迁移工具

### PC客户端整体架构图 (侧车进程主导架构)
```
┌─────────────────────────────────────────────────────────────┐
│                    Tauri 2.0 三层分离架构                     │
├─────────────────────────────────────────────────────────────┤
│                   前端层 (UI Rendering Layer)                │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │           React + TypeScript + shadcn/ui             │  │
│  │    ┌─────────┬─────────┬─────────┬─────────┐        │  │
│  │    │ 任务管理 │ 数据展示 │ 插件管理 │ 系统监控 │        │  │
│  │    │   UI    │   UI    │   UI    │   UI    │        │  │
│  │    └─────────┴─────────┴─────────┴─────────┘        │  │
│  │         Vite + 热重载 + Zustand + React Query        │  │
│  └─────────────────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────────────┤
│                 Tauri Commands & HTTP API                  │
│              (前端 ↔ 调度器 ↔ 侧车进程通信)                    │
├─────────────────────────────────────────────────────────────┤
│                后端层 (Scheduling Layer)                    │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │              Rust 进程调度器 + Tokio                   │  │
│  │    ┌─────────┬─────────┬─────────┬─────────┐        │  │
│  │    │侧车管理 │任务队列 │资源监控 │故障恢复  │        │  │
│  │    │ Manager │ Queue  │Monitor │Recovery │        │  │
│  │    └─────────┴─────────┴─────────┴─────────┘        │  │
│  │           进程生命周期管理 + 负载均衡                  │  │
│  └─────────────────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────────────┤
│               侧车进程层 (Business Logic Layer)              │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │            Node.js 侧车进程集群                        │  │
│  │    ┌─────────┬─────────┬─────────┬─────────┐        │  │
│  │    │ Crawlee │Playwright│ AI集成  │ 插件系统 │        │  │
│  │    │ 爬虫框架 │ 浏览器   │FastGPT │ Plugins │        │  │
│  │    └─────────┴─────────┴─────────┴─────────┘        │  │
│  │      会话管理 + 代理轮换 + 反反爬 + 工作流引擎         │  │
│  └─────────────────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────────────┤
│              本地数据存储层 (SQLite + File System)            │
└─────────────────────────────────────────────────────────────┘
```

### 项目目录结构

```
e-commerce-ai-platform/
├── src/                         # 前端源码 (React + TypeScript)
│   ├── components/              # UI组件
│   │   ├── Layout/              # 布局组件
│   │   ├── TaskManager/         # 任务管理组件
│   │   ├── ProductManager/      # 商品管理组件
│   │   ├── DataAnalysis/        # 数据分析组件
│   │   └── Settings/            # 设置组件
│   ├── pages/                   # 页面组件
│   ├── hooks/                   # React Hooks
│   ├── store/                   # 状态管理(Zustand)
│   ├── services/                # 前端服务层
│   │   ├── crawler/             # 爬虫服务 (Crawlee + Playwright)
│   │   │   ├── crawlee-service.ts # Crawlee爬虫服务
│   │   │   ├── playwright-service.ts # Playwright浏览器服务
│   │   │   ├── session-manager.ts # 会话管理
│   │   │   ├── proxy-manager.ts # 代理管理
│   │   │   ├── fingerprint-manager.ts # 指纹管理
│   │   │   └── anti-detection.ts # 反反爬策略
│   │   ├── ai/                  # AI服务
│   │   │   ├── fastgpt-service.ts # FastGPT API集成
│   │   │   └── analysis-service.ts # 数据分析服务
│   │   ├── workflow/            # 工作流引擎
│   │   │   ├── workflow-engine.ts # 工作流引擎
│   │   │   ├── task-scheduler.ts # 任务调度器
│   │   │   └── pipeline-manager.ts # 管道管理
│   │   └── plugins/             # 插件系统
│   │       ├── scraper-plugins/ # 爬虫插件
│   │       ├── publisher-plugins/ # 上品插件
│   │       └── analyzer-plugins/ # 分析插件
│   ├── utils/                   # 前端工具函数
│   ├── types/                   # 前端类型定义
│   ├── App.tsx                  # 主应用组件
│   ├── main.tsx                 # React入口
│   └── index.html               # HTML模板
├── src-tauri/                   # Tauri后端源码 (Rust) - 简化版
│   ├── src/                     # Rust源码
│   │   ├── main.rs              # 主入口文件
│   │   ├── lib.rs               # 库入口文件
│   │   ├── commands/            # Tauri命令 (简化)
│   │   │   ├── mod.rs           # 命令模块
│   │   │   ├── system.rs        # 系统命令
│   │   │   ├── database.rs      # 数据库命令
│   │   │   ├── filesystem.rs    # 文件系统命令
│   │   │   └── process.rs       # 进程管理命令
│   │   ├── services/            # 系统服务 (简化)
│   │   │   ├── mod.rs           # 服务模块
│   │   │   ├── process_manager.rs # 进程管理服务
│   │   │   └── resource_monitor.rs # 资源监控服务
│   │   ├── models/              # 数据模型
│   │   │   ├── mod.rs           # 模型模块
│   │   │   ├── product.rs       # 商品模型
│   │   │   ├── task.rs          # 任务模型
│   │   │   └── system.rs        # 系统模型
│   │   ├── database/            # 数据库操作
│   │   │   ├── mod.rs           # 数据库模块
│   │   │   ├── connection.rs    # 数据库连接
│   │   │   └── migrations.rs    # 数据库迁移
│   │   ├── utils/               # 工具函数
│   │   │   ├── mod.rs           # 工具模块
│   │   │   ├── logger.rs        # 日志系统
│   │   │   ├── config.rs        # 配置管理
│   │   │   └── helpers.rs       # 辅助函数
│   │   └── events.rs            # 事件系统
│   ├── Cargo.toml               # Rust依赖配置
│   ├── tauri.conf.json          # Tauri配置文件
│   ├── build.rs                 # 构建脚本
│   └── icons/                   # 应用图标
├── sidecar-crawler/             # Node.js侧车进程
│   ├── src/                     # 侧车进程源码
│   │   ├── main.js             # 侧车进程入口
│   │   ├── crawler/            # 爬虫引擎
│   │   │   ├── CrawlerEngine.js # 爬虫引擎核心
│   │   │   ├── BrowserManager.js # 浏览器管理
│   │   │   └── TaskQueue.js    # 任务队列
│   │   ├── platforms/          # 平台适配器
│   │   │   ├── PlatformManager.js # 平台管理器
│   │   │   ├── taobao.js       # 淘宝适配器
│   │   │   ├── jd.js           # 京东适配器
│   │   │   └── amazon.js       # 亚马逊适配器
│   │   └── utils/              # 工具函数
│   │       ├── Logger.js       # 日志工具
│   │       ├── ProxyManager.js # 代理管理
│   │       └── AntiDetection.js # 反检测工具
│   ├── bin/                     # 编译后的二进制文件
│   │   ├── crawler-sidecar-x86_64-apple-darwin
│   │   ├── crawler-sidecar-x86_64-pc-windows-msvc.exe
│   │   └── crawler-sidecar-x86_64-unknown-linux-gnu
│   ├── package.json            # 侧车进程依赖
│   ├── build.js                # 构建脚本
│   └── README.md               # 侧车进程文档
├── shared/                      # 前后端共享代码
│   ├── types/                   # 共享类型定义
│   ├── constants/               # 常量定义
│   └── utils/                   # 通用工具
├── public/                      # 静态资源
│   ├── icons/                   # 应用图标
│   └── assets/                  # 静态资源文件
├── plugins-config/              # 插件配置
│   ├── crawlee-scrapers.json   # Crawlee爬虫配置
│   ├── publishers.json         # 上品配置
│   ├── analyzers.json          # 分析器配置
│   ├── accounts.json           # 账号池配置
│   ├── proxies.json            # 代理池配置
│   ├── fingerprints.json       # 指纹模板配置
│   └── anti-detection.json     # 反检测策略配置
├── workflows/                   # 工作流定义
│   ├── default-workflow.json   # 默认工作流
│   └── custom-workflows/       # 自定义工作流
├── data/                        # 数据目录
│   ├── products/               # 商品数据
│   ├── analysis/               # 分析结果
│   ├── cookies/                # Cookie存储
│   │   ├── taobao/             # 淘宝Cookie
│   │   ├── jd/                 # 京东Cookie
│   │   └── amazon/             # 亚马逊Cookie
│   ├── sessions/               # 浏览器会话
│   ├── fingerprints/           # 浏览器指纹
│   ├── proxies/                # 代理配置
│   └── logs/                   # 日志文件
├── tests/                       # 测试文件
│   ├── unit/                   # 单元测试
│   ├── integration/            # 集成测试
│   └── e2e/                    # 端到端测试
├── docs/                        # 文档
├── scripts/                     # 构建脚本
│   ├── build.js                # 构建脚本
│   ├── dev.js                  # 开发脚本
│   └── setup.js                # 环境设置脚本
├── vite.config.ts              # Vite配置文件
├── tsconfig.json               # TypeScript配置
├── tsconfig.node.json          # Node.js TypeScript配置
├── package.json                # 前端依赖配置
├── pnpm-lock.yaml              # 依赖锁定文件
├── .gitignore                  # Git忽略文件
├── .env                        # 环境变量
└── README.md                   # 项目说明
```

### PC客户端特有功能

**桌面集成功能**:
- **系统托盘**: 基于Tauri的系统托盘API，支持最小化到托盘
- **开机自启**: 使用Tauri的autostart插件，支持开机自动启动
- **全局快捷键**: Tauri全局快捷键API，快速唤起应用窗口
- **系统通知**: Tauri通知API，支持原生系统通知
- **文件关联**: Tauri文件系统API，支持拖拽和文件关联
- **剪贴板监听**: Tauri剪贴板API，自动识别商品链接
- **深度链接**: 支持自定义URL协议，从浏览器直接打开应用

**窗口管理**:
- **多窗口支持**: Tauri多窗口管理，支持主窗口、设置窗口等
- **窗口状态保存**: 自动保存和恢复窗口位置、大小状态
- **原生窗口控制**: 支持最大化、最小化、全屏等原生操作
- **窗口装饰**: 自定义标题栏和窗口边框
- **窗口置顶**: 支持窗口置顶显示功能

**性能优化**:
- **Rust后端**: 极致性能的Rust后端处理
- **异步处理**: Tokio异步运行时，高效处理并发任务
- **内存安全**: Rust的内存安全特性，避免内存泄漏
- **轻量级**: 相比Electron显著减少内存占用和安装包大小
- **原生性能**: 接近原生应用的性能表现

**安全特性**:
- **沙箱机制**: Tauri的安全沙箱，限制前端对系统的访问
- **CSP策略**: 内容安全策略，防止XSS攻击
- **权限系统**: 细粒度的权限控制，最小权限原则
- **代码签名**: 支持应用程序数字签名
- **安全更新**: 内置安全更新机制

### 开发和部署架构

**开发环境**:
- **热重载**: Vite前端热重载 + Tauri后端热重载，极速开发体验
- **调试工具**: 前端Chrome DevTools + Rust调试工具集成
- **类型检查**: 前端TypeScript + 后端Rust类型安全
- **代码规范**: 前端ESLint/Prettier + 后端Clippy/Rustfmt
- **跨语言绑定**: TypeScript与Rust类型安全绑定

**构建打包**:
- **前端构建**: Vite构建优化的Web资源
- **侧车进程构建**: 使用pkg将Node.js应用打包为自包含二进制文件
  - 支持多平台: macOS (x64)、Windows (x64)、Linux (x64)
  - 自包含运行时: 无需用户安装Node.js环境
  - 二进制重命名: 符合Tauri target triple命名规范
- **后端编译**: Cargo编译高性能Rust代码
- **资源嵌入**: 前端资源和侧车二进制文件嵌入Rust二进制文件
- **多平台构建**: Windows (MSI/NSIS)、macOS (DMG/APP)、Linux (AppImage/DEB)
- **代码签名**: 支持Windows Authenticode和macOS代码签名
- **自动更新**: Tauri内置更新机制，支持增量更新
- **安装包优化**: 相比Electron减少70%安装包体积
- **交叉编译**: 支持GitHub Actions交叉平台编译

**分发部署**:
- **应用商店**: 支持Microsoft Store、Mac App Store、Snap Store
- **官网下载**: 直接下载原生安装包
- **企业部署**: 支持企业内部分发和侧载
- **版本管理**: 多版本并存，支持回滚机制
- **CI/CD集成**: GitHub Actions + Tauri Action自动化构建发布

## 🔌 混合架构设计 (前端 + 侧车进程)

### 架构演进说明

**三层分离架构优势**:
- **前端专注渲染**: React + TypeScript提供现代化UI和数据展示
- **侧车进程主导业务**: Node.js侧车集中处理所有爬虫、AI分析、插件功能
- **Rust后端专注调度**: 负责侧车进程管理、任务调度和资源监控
- **业务能力分离**: 实现UI渲染、业务逻辑、进程调度的完全分离

### 🚀 Tauri侧车进程架构 (核心业务层)

**侧车进程设计理念**:
- **业务集中**: 所有爬虫、AI分析、插件功能集中在侧车进程中
- **进程隔离**: 业务逻辑运行在独立的Node.js进程中，确保主应用UI响应性
- **热插拔支持**: 支持插件和平台适配器的动态加载和更新
- **资源管理**: 可以独立控制内存和CPU使用，支持多实例负载均衡
- **故障恢复**: 侧车进程崩溃不会影响主应用，支持自动重启和故障转移
- **跨平台兼容**: 打包为自包含二进制文件，无需用户安装Node.js

**侧车进程架构图**:
```
┌─────────────────────────────────────────────────────────────┐
│                  Tauri 2.0 三层分离架构                       │
├─────────────────────────────────────────────────────────────┤
│                   前端层 (UI Rendering Layer)                │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │           React + TypeScript + shadcn/ui             │  │
│  │    ┌─────────┬─────────┬─────────┬─────────┐        │  │
│  │    │ 任务管理 │ 数据展示 │ 插件管理 │ 系统监控 │        │  │
│  │    │   UI    │   UI    │   UI    │   UI    │        │  │
│  │    └─────────┴─────────┴─────────┴─────────┘        │  │
│  │         Vite + 热重载 + Zustand + React Query        │  │
│  └─────────────────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────────────┤
│                 Tauri Commands & HTTP API                  │
│              (前端 ↔ 调度器 ↔ 侧车进程通信)                    │
├─────────────────────────────────────────────────────────────┤
│                后端层 (Scheduling Layer)                    │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │              Rust 进程调度器 + Tokio                   │  │
│  │    ┌─────────┬─────────┬─────────┬─────────┐        │  │
│  │    │侧车管理 │任务队列 │资源监控 │故障恢复  │        │  │
│  │    │ Manager │ Queue  │Monitor │Recovery │        │  │
│  │    └─────────┴─────────┴─────────┴─────────┘        │  │
│  │           进程生命周期管理 + 负载均衡                  │  │
│  └─────────────────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────────────┤
│               侧车进程层 (Business Logic Layer)              │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │            Node.js 侧车进程集群                        │  │
│  │    ┌─────────┬─────────┬─────────┬─────────┐        │  │
│  │    │ Crawlee │Playwright│ AI集成  │ 插件系统 │        │  │
│  │    │ 爬虫框架 │ 浏览器   │FastGPT │ Plugins │        │  │
│  │    └─────────┴─────────┴─────────┴─────────┘        │  │
│  │      会话管理 + 代理轮换 + 反反爬 + 工作流引擎         │  │
│  └─────────────────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────────────┤
│                后端层 (Data Storage Layer)                  │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                SQLite + File System                  │  │
│  │    ┌─────────┬─────────┬─────────┬─────────┐        │  │
│  │    │ 任务数据 │ 商品数据 │ 配置数据 │ 日志数据 │        │  │
│  │    └─────────┴─────────┴─────────┴─────────┘        │  │
│  │              数据持久化 + 备份恢复                   │  │
│  └─────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 1. Node.js侧车业务系统 (核心业务层)

**架构说明**:
- **侧车进程实现**: 使用Node.js + Crawlee + Playwright构建独立的业务进程
- **业务集中**: 集中处理所有爬虫、AI分析、插件功能
- **前端渲染**: React前端专注UI渲染和数据展示
- **Rust调度管理**: 负责侧车进程的生命周期管理、任务调度和资源监控

### 🔧 侧车进程技术实现

**1. 侧车进程配置 (tauri.conf.json)**:

```json
{
  "bundle": {
    "externalBin": [
      {
        "name": "crawler-sidecar",
        "src": "sidecar-crawler/bin/crawler-sidecar-x86_64-apple-darwin",
        "targets": ["x86_64-apple-darwin"]
      },
      {
        "name": "crawler-sidecar",
        "src": "sidecar-crawler/bin/crawler-sidecar-x86_64-pc-windows-msvc.exe",
        "targets": ["x86_64-pc-windows-msvc"]
      },
      {
        "name": "crawler-sidecar",
        "src": "sidecar-crawler/bin/crawler-sidecar-x86_64-unknown-linux-gnu",
        "targets": ["x86_64-unknown-linux-gnu"]
      }
    ]
  }
}
```

**2. 侧车进程权限配置 (src-tauri/capabilities/default.json)**:

```json
{
  "permissions": [
    "shell:allow-execute",
    "shell:allow-spawn",
    "core:default",
    "core:event:default"
  ]
}
```

**3. Node.js侧车进程实现 (sidecar-crawler/src/main.js)**:

```javascript
// 侧车进程主入口
const { CrawlerEngine } = require('./crawler/CrawlerEngine');
const { PlatformManager } = require('./platforms/PlatformManager');
const { Logger } = require('./utils/Logger');

class CrawlerSidecar {
  constructor() {
    this.engine = new CrawlerEngine();
    this.platformManager = new PlatformManager();
    this.logger = new Logger('CrawlerSidecar');
  }

  async start() {
    try {
      // 启动HTTP服务器用于接收任务
      this.server = require('http').createServer(this.handleRequest.bind(this));
      this.server.listen(0, () => {
        const port = this.server.address().port;
        console.log(`SIDECAR_PORT:${port}`);
        this.logger.info(`Crawler sidecar started on port ${port}`);
      });
    } catch (error) {
      this.logger.error('Failed to start sidecar:', error);
      process.exit(1);
    }
  }

  async handleRequest(req, res) {
    if (req.method === 'POST' && req.url === '/crawl') {
      let body = '';
      req.on('data', chunk => body += chunk);
      req.on('end', async () => {
        try {
          const task = JSON.parse(body);
          const result = await this.engine.executeCrawlTask(task);
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify(result));
        } catch (error) {
          res.writeHead(500, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: error.message }));
        }
      });
    } else {
      res.writeHead(404);
      res.end('Not Found');
    }
  }
}

if (require.main === module) {
  new CrawlerSidecar().start();
}
```

**4. 前端侧车进程管理器 (src/services/sidecar/SidecarManager.ts)**:

```typescript
import { Command } from '@tauri-apps/plugin-shell';
import { invoke } from '@tauri-apps/api/core';

export class SidecarManager {
  private sidecarProcess?: Child;
  private sidecarPort?: number;
  private isRunning = false;

  async startSidecar(): Promise<void> {
    if (this.isRunning) return;

    try {
      // 启动侧车进程
      const command = Command.sidecar('crawler-sidecar');
      this.sidecarProcess = await command.spawn();
      
      // 监听输出获取端口号
      this.sidecarProcess.stdout.on('data', (data) => {
        const output = new TextDecoder().decode(data);
        const portMatch = output.match(/SIDECAR_PORT:(\d+)/);
        if (portMatch) {
          this.sidecarPort = parseInt(portMatch[1]);
          this.isRunning = true;
        }
      });

      // 监听进程退出
      this.sidecarProcess.on('close', (code) => {
        console.log(`Sidecar process exited with code ${code}`);
        this.isRunning = false;
        this.sidecarPort = undefined;
      });

    } catch (error) {
      console.error('Failed to start sidecar:', error);
      throw error;
    }
  }

  async stopSidecar(): Promise<void> {
    if (this.sidecarProcess) {
      await this.sidecarProcess.kill();
      this.isRunning = false;
      this.sidecarPort = undefined;
    }
  }

  async executeCrawlTask(task: CrawlTask): Promise<CrawlResult> {
    if (!this.isRunning || !this.sidecarPort) {
      throw new Error('Sidecar process is not running');
    }

    const response = await fetch(`http://localhost:${this.sidecarPort}/crawl`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(task)
    });

    if (!response.ok) {
      throw new Error(`Sidecar request failed: ${response.statusText}`);
    }

    return await response.json();
  }
}
```

**5. 侧车进程构建脚本 (sidecar-crawler/build.js)**:

```javascript
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// 使用pkg打包Node.js应用为二进制文件
const targets = [
  'node18-macos-x64',
  'node18-win-x64', 
  'node18-linux-x64'
];

const outputNames = {
  'node18-macos-x64': 'crawler-sidecar-x86_64-apple-darwin',
  'node18-win-x64': 'crawler-sidecar-x86_64-pc-windows-msvc.exe',
  'node18-linux-x64': 'crawler-sidecar-x86_64-unknown-linux-gnu'
};

// 确保输出目录存在
if (!fs.existsSync('bin')) {
  fs.mkdirSync('bin');
}

// 为每个平台构建二进制文件
targets.forEach(target => {
  const outputName = outputNames[target];
  console.log(`Building for ${target}...`);
  
  try {
    execSync(`npx pkg src/main.js --target ${target} --output bin/${outputName}`, {
      stdio: 'inherit'
    });
    console.log(`✅ Built ${outputName}`);
  } catch (error) {
    console.error(`❌ Failed to build ${outputName}:`, error.message);
  }
});
```

### 🎯 爬虫插件基类设计

**基类设计 (TypeScript)**:
- `BaseScraper`: 所有爬虫插件的基类
- 必须实现的方法:
  - `scrapeProduct(url)`: 抓取单个商品
  - `scrapeCategory(categoryUrl, options)`: 抓取分类页面
  - `searchProducts(keyword, options)`: 搜索商品
- 可选实现的方法:
  - `login(credentials)`: 登录认证
  - `validateProduct(productData)`: 数据验证

**前端Crawlee + Playwright配置**:

**前端Crawlee框架特性**:
- **智能重试机制**: 自动处理失败请求和网络错误
- **请求队列管理**: 内置队列系统，支持优先级和去重
- **会话管理**: 自动管理Cookie和浏览器会话
- **代理轮换**: 内置代理池管理和自动轮换
- **反反爬策略**: 集成多种反检测技术
- **数据存储**: 支持多种存储后端(内存、文件、数据库)
- **监控和统计**: 实时爬虫性能监控
- **前端集成**: 完全在前端运行，通过Tauri API与后端通信存储数据

**1. 前端Crawlee PlaywrightCrawler配置**:
```typescript
// src/services/crawler/crawlee-service.ts
import { PlaywrightCrawler, Dataset } from 'crawlee';
import { invoke } from '@tauri-apps/api/tauri';

// 前端Crawlee爬虫配置
class FrontendCrawleeService {
  private crawler: PlaywrightCrawler;
  
  constructor() {
    this.crawler = new PlaywrightCrawler({
      // 浏览器配置
      launchContext: {
        launchOptions: {
          headless: false,  // 非无头模式
          slowMo: 100,      // 操作延迟
          args: [
            '--disable-blink-features=AutomationControlled',
            '--disable-web-security',
            '--disable-features=VizDisplayCompositor'
          ]
        }
      },
      // 请求处理配置
      maxRequestsPerCrawl: 1000,
      maxConcurrency: 5,
      requestHandlerTimeoutSecs: 60,
      // 会话池配置
      sessionPoolOptions: {
        maxPoolSize: 50,
        sessionOptions: {
          maxUsageCount: 50,
          maxErrorScore: 3
        }
      },
      // 数据处理器 - 通过Tauri API保存到后端
      requestHandler: async ({ page, request, session }) => {
        const data = await this.extractData(page);
        // 通过Tauri API保存数据到Rust后端
        await invoke('save_product_data', { data });
      }
    });
  }
  
  private async extractData(page: Page): Promise<any> {
    // 数据提取逻辑
    return {};
  }
}
```

**2. 前端Crawlee会话和Cookie管理**:
```typescript
// src/services/crawler/session-manager.ts
import { SessionPool, Session } from 'crawlee';
import { invoke } from '@tauri-apps/api/tauri';

// 前端Crawlee会话管理
class FrontendSessionManager {
  private sessionPool: SessionPool;
  
  constructor() {
    this.sessionPool = new SessionPool({
      maxPoolSize: 50,
      sessionOptions: {
        maxUsageCount: 50,
        maxErrorScore: 3,
        maxAgeSecs: 3600 // 1小时会话过期
      },
      persistStateKey: 'session-pool-state'
    });
  }
}

// 前端Cookie管理器
class FrontendCookieManager {
  private sessionPool: SessionPool;
  
  constructor(sessionPool: SessionPool) {
    this.sessionPool = sessionPool;
  }
  
  async getSessionForAccount(accountId: string, platform: string): Promise<Session> {
    const session = await this.sessionPool.getSession(`${platform}-${accountId}`);
    return session;
  }
  
  async saveAccountSession(accountId: string, platform: string, session: Session): Promise<void> {
    // Crawlee自动管理会话持久化
    session.userData.accountId = accountId;
    session.userData.platform = platform;
    // 通过Tauri API保存会话信息到后端
    await invoke('save_session_data', { 
      accountId, 
      platform, 
      sessionData: session.userData 
    });
  }
  
  async rotateSession(platform: string): Promise<Session> {
    return await this.sessionPool.getSession();
  }
}
```

**3. 前端多账号隔离系统**:
```typescript
// src/services/crawler/account-pool.ts
import { invoke } from '@tauri-apps/api/tauri';

// 前端账号池管理
class FrontendAccountPool {
  private accounts: Map<string, AccountInfo> = new Map();
  
  async getAvailableAccount(platform: string): Promise<AccountInfo> {
    // 从Rust后端获取可用账号
    const accountData = await invoke('get_available_account', { platform });
    return accountData as AccountInfo;
  }
  
  async markAccountBusy(accountId: string, duration: number): Promise<void> {
    await invoke('mark_account_busy', { accountId, duration });
  }
  
  async releaseAccount(accountId: string): Promise<void> {
    await invoke('release_account', { accountId });
  }
  
  async rotateAccount(platform: string): Promise<AccountInfo> {
    return await invoke('rotate_account', { platform });
  }
}

// 账号信息结构
interface AccountInfo {
  id: string;
  platform: string;
  credentials: {
    username: string;
    password: string;
    phone?: string;
  };
  proxy?: ProxyConfig;
  fingerprint: BrowserFingerprint;
  status: 'available' | 'busy' | 'banned' | 'cooling';
  lastUsed: Date;
  usageCount: number;
  cookieStorage: string; // Cookie存储路径
}
```

**4. 前端浏览器指纹模拟**:
```typescript
// src/services/crawler/fingerprint-manager.ts
import { Page } from 'playwright';
import { invoke } from '@tauri-apps/api/tauri';

// 浏览器指纹配置
interface BrowserFingerprint {
  userAgent: string;
  viewport: { width: number; height: number };
  locale: string;
  timezone: string;
  platform: string;
  webgl: {
    vendor: string;
    renderer: string;
  };
  fonts: string[];
  plugins: string[];
  canvas: {
    noise: boolean;
    shift: number;
  };
}

// 前端指纹生成器
class FrontendFingerprintGenerator {
  async generateRandomFingerprint(): Promise<BrowserFingerprint> {
    // 从Rust后端获取随机指纹
    return await invoke('generate_random_fingerprint');
  }
  
  async applyFingerprint(page: Page, fingerprint: BrowserFingerprint): Promise<void> {
    // 在前端应用指纹到Playwright页面
    await page.setUserAgent(fingerprint.userAgent);
    await page.setViewportSize(fingerprint.viewport);
    await page.addInitScript((fp) => {
      Object.defineProperty(navigator, 'platform', { get: () => fp.platform });
      Object.defineProperty(navigator, 'language', { get: () => fp.locale });
    }, fingerprint);
  }
  
  async rotateFingerprint(accountId: string): Promise<BrowserFingerprint> {
    return await invoke('rotate_fingerprint', { accountId });
  }
}
```

**5. 前端反反爬策略**:
```typescript
// src/services/crawler/anti-detection.ts
import { Page, Request } from 'playwright';
import { invoke } from '@tauri-apps/api/tauri';

// 前端反反爬配置
class FrontendAntiDetectionConfig {
  // 随机延迟
  randomDelay: { min: number; max: number } = { min: 1000, max: 3000 };
  
  // 鼠标轨迹模拟
  mouseMovement: {
    enabled: boolean;
    naturalMovement: boolean;
    randomClicks: boolean;
  };
  
  // 滚动行为模拟
  scrollBehavior: {
    enabled: boolean;
    randomScroll: boolean;
    humanLikeSpeed: boolean;
  };
  
  // 请求头随机化
  headerRandomization: {
    acceptLanguage: string[];
    acceptEncoding: string[];
    connection: string[];
  };
}

// 前端反检测策略管理器
class FrontendAntiDetectionManager {
  private config: FrontendAntiDetectionConfig;
  
  constructor(config: FrontendAntiDetectionConfig) {
    this.config = config;
  }
  
  async applyRandomDelay(): Promise<void> {
    const delay = Math.random() * (this.config.randomDelay.max - this.config.randomDelay.min) + this.config.randomDelay.min;
    await new Promise(resolve => setTimeout(resolve, delay));
  }
  
  async simulateHumanBehavior(page: Page): Promise<void> {
    if (this.config.mouseMovement.enabled) {
      // 模拟自然鼠标移动
      await page.mouse.move(
        Math.random() * 800, 
        Math.random() * 600,
        { steps: Math.floor(Math.random() * 10) + 5 }
      );
    }
    
    if (this.config.scrollBehavior.enabled) {
      // 模拟人类滚动行为
      await page.evaluate(() => {
        const scrollAmount = Math.random() * 300 + 100;
        window.scrollBy({
          top: scrollAmount,
          behavior: 'smooth'
        });
      });
    }
  }
  
  async rotateHeaders(): Promise<Record<string, string>> {
    // 通过Tauri API获取随机请求头
    return await invoke('get_random_headers', { config: this.config.headerRandomization });
  }
}
```

**6. 前端Crawlee代理管理系统**:
```typescript
// src/services/crawler/proxy-manager.ts
import { ProxyConfiguration } from 'crawlee';
import { invoke } from '@tauri-apps/api/tauri';

// 前端Crawlee代理配置
class FrontendCrawleeProxyService {
  private proxyConfiguration: ProxyConfiguration;
  private proxyStats: Map<string, ProxyStats> = new Map();
  
  constructor() {
    // 初始化时从Rust后端获取代理配置
    this.initializeProxyConfiguration();
  }
  
  private async initializeProxyConfiguration(): Promise<void> {
    const proxyUrls = await invoke('get_proxy_urls') as string[];
    
    this.proxyConfiguration = new ProxyConfiguration({
      proxyUrls,
      // 自动代理轮换 - 通过Tauri API获取
      newUrlFunction: async (sessionId?: string) => {
        return await invoke('get_next_available_proxy', { sessionId });
      }
    });
  }
  
  async getProxyUrl(sessionId?: string): Promise<string | undefined> {
    return await this.proxyConfiguration.newUrl(sessionId);
  }
  
  async markProxyFailed(proxyUrl: string): Promise<void> {
    const stats = this.proxyStats.get(proxyUrl) || { failures: 0, successes: 0 };
    stats.failures++;
    stats.lastUsed = new Date();
    this.proxyStats.set(proxyUrl, stats);
    
    // 通知Rust后端代理失败
    await invoke('mark_proxy_failed', { proxyUrl, stats });
  }
  
  async markProxySuccess(proxyUrl: string): Promise<void> {
    const stats = this.proxyStats.get(proxyUrl) || { failures: 0, successes: 0 };
    stats.successes++;
    stats.lastUsed = new Date();
    this.proxyStats.set(proxyUrl, stats);
    
    // 通知Rust后端代理成功
    await invoke('mark_proxy_success', { proxyUrl, stats });
  }
  
  async testProxyHealth(proxyUrl: string): Promise<boolean> {
    return await invoke('test_proxy_health', { proxyUrl });
  }
  
  async rotateProxy(): Promise<string> {
    return await invoke('rotate_proxy');
  }
  
  async getProxyStats(): Promise<Map<string, ProxyStats>> {
    const statsData = await invoke('get_proxy_stats');
    return new Map(Object.entries(statsData as Record<string, ProxyStats>));
  }
}

interface ProxyStats {
  failures: number;
  successes: number;
  lastUsed?: Date;
  responseTime?: number;
  isHealthy?: boolean;
}
```

**7. 前端Crawlee请求处理和会话管理**:
```typescript
// src/services/crawler/scraping-session.ts
import { PlaywrightCrawler, Request, SessionPool, Session } from 'crawlee';
import { Page } from 'playwright';
import { invoke } from '@tauri-apps/api/tauri';
import { FrontendCrawleeProxyService } from './proxy-manager';
import { FrontendAntiDetectionManager } from './anti-detection';

// 前端Crawlee爬虫会话管理
class FrontendCrawleeScrapingSession {
  private crawler: PlaywrightCrawler;
  private sessionPool: SessionPool;
  private proxyManager: FrontendCrawleeProxyService;
  private antiDetection: FrontendAntiDetectionManager;
  
  constructor(config: CrawlerConfig) {
    this.proxyManager = new FrontendCrawleeProxyService();
    this.antiDetection = new FrontendAntiDetectionManager(config.antiDetection);
    this.initializeCrawler(config);
  }
  
  private async initializeCrawler(config: CrawlerConfig): Promise<void> {
    this.crawler = new PlaywrightCrawler({
      // 请求处理器 - 前端实现
      requestHandler: async ({ page, request, session, proxyInfo }) => {
        // 自动处理会话、代理、反检测
        await this.handleRequest(page, request, session, proxyInfo);
      },
      // 失败处理器 - 前端实现
      failedRequestHandler: async ({ request, error }) => {
        console.log(`Request ${request.url} failed: ${error.message}`);
        // 通过Tauri API记录失败到Rust后端
        await invoke('log_request_failure', {
          url: request.url,
          error: error.message,
          timestamp: new Date().toISOString()
        });
        // Crawlee自动重试机制
      },
      // 会话池配置
      sessionPoolOptions: {
        maxPoolSize: 50,
        sessionOptions: {
          maxUsageCount: 50,
          maxErrorScore: 3
        }
      },
      // 代理配置 - 前端管理
      proxyConfiguration: this.proxyManager.proxyConfiguration
    });
  }
  
  async handleRequest(page: Page, request: Request, session: Session, proxyInfo: any): Promise<void> {
    try {
      // 自动应用反检测策略
      await this.applyAntiDetection(page, session);
      
      // 处理验证码
      if (await this.detectCaptcha(page)) {
        await this.handleCaptcha(page, session);
      }
      
      // 检测封禁
      if (await this.detectBlocking(page)) {
        session.markBad();
        throw new Error('Session blocked');
      }
      
      // 提取数据
      const data = await this.extractPageData(page, request);
      
      // 通过Tauri API保存数据到Rust后端
      await invoke('save_scraped_data', {
        url: request.url,
        data,
        sessionId: session.id,
        timestamp: new Date().toISOString()
      });
      
    } catch (error) {
      console.error('Request handling failed:', error);
      throw error;
    }
  }
  
  async applyAntiDetection(page: Page, session: Session): Promise<void> {
    // Crawlee内置反检测 + 自定义策略
    await page.addInitScript(() => {
      // 移除webdriver标识
      Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
      // 移除自动化标识
      delete (window as any).chrome.runtime;
    });
    
    // 应用反检测管理器策略
    await this.antiDetection.simulateHumanBehavior(page);
    await this.antiDetection.applyRandomDelay();
  }
  
  async detectCaptcha(page: Page): Promise<boolean> {
    // 验证码检测逻辑
    const captchaCount = await page.locator('[class*="captcha"], [id*="captcha"], .recaptcha, #recaptcha').count();
    
    if (captchaCount > 0) {
      // 通过Tauri API记录验证码检测
      await invoke('log_captcha_detected', {
        url: page.url(),
        timestamp: new Date().toISOString()
      });
    }
    
    return captchaCount > 0;
  }
  
  async handleCaptcha(page: Page, session: Session): Promise<boolean> {
    // 验证码处理逻辑
    session.markBad(); // 标记会话需要人工处理
    
    // 通过Tauri API通知用户需要处理验证码
    await invoke('notify_captcha_required', {
      url: page.url(),
      sessionId: session.id
    });
    
    return false;
  }
  
  async detectBlocking(page: Page): Promise<boolean> {
    // 封禁检测逻辑
    const title = await page.title();
    const isBlocked = title.includes('访问被拒绝') || 
                     title.includes('Access Denied') ||
                     title.includes('403') ||
                     title.includes('Forbidden');
    
    if (isBlocked) {
      // 通过Tauri API记录封禁检测
      await invoke('log_blocking_detected', {
        url: page.url(),
        title,
        timestamp: new Date().toISOString()
      });
    }
    
    return isBlocked;
  }
  
  async extractPageData(page: Page, request: Request): Promise<any> {
    // 根据平台类型提取数据
    const platform = request.userData?.platform || 'generic';
    
    switch (platform) {
      case 'taobao':
        return await this.extractTaobaoData(page);
      case 'jd':
        return await this.extractJDData(page);
      case 'pdd':
        return await this.extractPDDData(page);
      default:
        return await this.extractGenericData(page);
    }
  }
  
  private async extractTaobaoData(page: Page): Promise<any> {
    return {
      title: await page.textContent('.tb-detail-hd h1') || '',
      price: await page.textContent('.tb-rmb-num') || '',
      sales: await page.textContent('.tb-count') || '',
      rating: await page.textContent('.tb-rate-score') || ''
    };
  }
  
  private async extractJDData(page: Page): Promise<any> {
    return {
      title: await page.textContent('.sku-name') || '',
      price: await page.textContent('.price') || '',
      sales: await page.textContent('.sales-amount') || ''
    };
  }
  
  private async extractPDDData(page: Page): Promise<any> {
    return {
      title: await page.textContent('.goods-title') || '',
      price: await page.textContent('.goods-price') || '',
      sales: await page.textContent('.goods-sales') || ''
    };
  }
  
  private async extractGenericData(page: Page): Promise<any> {
    return {
      title: await page.title(),
      url: page.url(),
      content: await page.textContent('body')
    };
  }
  
  // 启动爬虫
  async start(urls: string[]): Promise<void> {
    await this.crawler.addRequests(urls);
    await this.crawler.run();
  }
  
  // 停止爬虫
  async stop(): Promise<void> {
    await this.crawler.teardown();
  }
}

// 爬虫配置接口
interface CrawlerConfig {
  headless: boolean;
  antiDetection: any;
  maxConcurrency: number;
  requestDelay: number;
}
```

**支持的平台**:
- 淘宝 (Taobao) - 支持多账号登录、Cookie持久化
- 京东 (JD) - 支持指纹模拟、代理轮换
- 拼多多 (PDD) - 支持反反爬、验证码处理
- 亚马逊 (Amazon) - 支持地区切换、多账号隔离
- 天猫 (Tmall) - 支持会话保持、行为模拟
- 其他电商平台 - 通用反检测策略

### 2. 上品插件系统

**基类设计**:
- `BasePublisher`: 所有上品插件的基类
- 必须实现的方法:
  - `publishProduct(productData)`: 发布商品
  - `updateProduct(productId, productData)`: 更新商品
  - `deleteProduct(productId)`: 删除商品
- 可选实现的方法:
  - `authenticate()`: 平台认证
  - `validateProductData(productData)`: 数据验证
  - `getProductStatus(productId)`: 获取商品状态

**支持的平台**:
- Shopify
- WooCommerce
- Magento
- 自定义API
- eBay
- Amazon Seller

## 🤖 前端AI分析模块设计

### 前端FastGPT集成

**核心功能**:
- 爆品分析和识别
- 市场趋势预测
- 商品优化建议
- 定价策略分析
- 竞争对手分析

**分析维度**:
- 销量趋势分析 (30%权重)
- 利润率计算 (30%权重)
- 市场竞争度评估 (20%权重)
- 消费者需求分析 (20%权重)

**前端API集成**:
- 前端直接调用FastGPT API
- 结构化数据输入和解析
- 智能结果解析和存储
- 批量分析支持和并发控制
- 通过Tauri API保存分析结果到后端

**前端FastGPT服务实现**:
```typescript
// src/services/ai/fastgpt-service.ts
import { invoke } from '@tauri-apps/api/tauri';

// 前端FastGPT API集成
class FrontendFastGPTService {
  private apiKey: string;
  private baseUrl: string;
  
  constructor(config: FastGPTConfig) {
    this.apiKey = config.apiKey;
    this.baseUrl = config.baseUrl;
  }
  
  async analyzeProduct(productData: ProductData): Promise<AIAnalysis> {
    try {
      // 在前端直接调用FastGPT API
      const response = await fetch(`${this.baseUrl}/api/chat`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          messages: [
            {
              role: 'system',
              content: '你是一个专业的电商产品分析师，请分析以下产品数据并提供详细的市场分析报告。包括竞争分析、市场趋势、定价策略和改进建议。'
            },
            {
              role: 'user',
              content: `请分析以下产品数据：\n${JSON.stringify(productData, null, 2)}`
            }
          ],
          temperature: 0.7,
          max_tokens: 2000
        })
      });
      
      if (!response.ok) {
        throw new Error(`FastGPT API请求失败: ${response.status}`);
      }
      
      const result = await response.json();
      const analysis = this.parseAnalysisResult(result);
      
      // 通过Tauri API保存分析结果到Rust后端
      await invoke('save_ai_analysis', {
        productId: productData.id,
        analysis,
        timestamp: new Date().toISOString()
      });
      
      return analysis;
      
    } catch (error) {
      console.error('FastGPT分析失败:', error);
      
      // 通过Tauri API记录错误
      await invoke('log_ai_analysis_error', {
        productId: productData.id,
        error: error.message,
        timestamp: new Date().toISOString()
      });
      
      throw error;
    }
  }
  
  async batchAnalyzeProducts(products: ProductData[]): Promise<AIAnalysis[]> {
    const analyses: AIAnalysis[] = [];
    
    // 批量分析，控制并发数量
    const batchSize = 3;
    for (let i = 0; i < products.length; i += batchSize) {
      const batch = products.slice(i, i + batchSize);
      const batchPromises = batch.map(product => this.analyzeProduct(product));
      
      try {
        const batchResults = await Promise.all(batchPromises);
        analyses.push(...batchResults);
        
        // 批次间延迟，避免API限流
        if (i + batchSize < products.length) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      } catch (error) {
        console.error(`批次 ${i}-${i + batchSize} 分析失败:`, error);
        // 继续处理下一批次
      }
    }
    
    return analyses;
  }
  
  private parseAnalysisResult(result: any): AIAnalysis {
    // 解析FastGPT返回的分析结果
    const content = result.choices?.[0]?.message?.content || result.content || '';
    
    // 使用正则表达式或JSON解析提取结构化数据
    try {
      // 尝试解析JSON格式的回复
      const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[1]);
      }
      
      // 如果不是JSON格式，则解析文本格式
      return this.parseTextAnalysis(content);
      
    } catch (error) {
      console.warn('解析AI分析结果失败，使用文本解析:', error);
      return this.parseTextAnalysis(content);
    }
  }
  
  private parseTextAnalysis(content: string): AIAnalysis {
    // 文本格式解析逻辑
    const sections = {
      competitiveAnalysis: this.extractSection(content, ['竞争分析', '竞品分析', 'competitive']),
      marketTrends: this.extractSection(content, ['市场趋势', '趋势分析', 'market trends']),
      pricingStrategy: this.extractSection(content, ['定价策略', '价格建议', 'pricing']),
      recommendations: this.extractSection(content, ['建议', '推荐', 'recommendations'])
    };
    
    return {
      competitiveAnalysis: sections.competitiveAnalysis || '暂无竞争分析',
      marketTrends: sections.marketTrends || '暂无市场趋势分析',
      pricingStrategy: sections.pricingStrategy || '暂无定价策略建议',
      recommendations: sections.recommendations || '暂无改进建议',
      rawContent: content,
      analysisDate: new Date().toISOString()
    };
  }
  
  private extractSection(content: string, keywords: string[]): string {
    for (const keyword of keywords) {
      const regex = new RegExp(`${keyword}[：:](.*?)(?=\n\n|\n[一二三四五六七八九十]|\n\d+\.|$)`, 'is');
      const match = content.match(regex);
      if (match) {
        return match[1].trim();
      }
    }
    return '';
  }
}

// FastGPT配置接口
interface FastGPTConfig {
  apiKey: string;
  baseUrl: string;
  model?: string;
  temperature?: number;
  maxTokens?: number;
}

// 产品数据接口
interface ProductData {
  id: string;
  title: string;
  price: number;
  sales: number;
  rating: number;
  reviews: number;
  category: string;
  brand?: string;
  features?: string[];
  images?: string[];
  description?: string;
}

// AI分析结果接口
interface AIAnalysis {
  competitiveAnalysis: string;
  marketTrends: string;
  pricingStrategy: string;
  recommendations: string;
  rawContent?: string;
  analysisDate?: string;
  confidence?: number;
}
```

## 📊 工作流引擎设计

### 前端轻量级工作流引擎

**设计原则**:
- 前端实现，简单易用，避免过度复杂
- 支持条件分支和错误处理
- JSON配置驱动
- 可视化监控
- 通过Tauri API与后端交互

**核心组件**:
1. **前端流程定义器**: JSON配置文件定义流程
2. **前端执行引擎**: 按步骤执行任务
3. **前端状态管理器**: 跟踪执行状态
4. **前端错误处理器**: 处理异常和重试
5. **前端监控器**: 记录执行日志和指标

**前端工作流引擎实现**:
```typescript
// src/services/workflow/lightweight-workflow.ts
import { invoke } from '@tauri-apps/api/tauri';
import { FrontendCrawleeScrapingSession } from '../crawler/scraping-session';
import { FrontendFastGPTService } from '../ai/fastgpt-service';

// 前端轻量级工作流引擎
class FrontendLightweightWorkflow {
  private workflows: Map<string, WorkflowConfig> = new Map();
  private executions: Map<string, WorkflowExecution> = new Map();
  
  // 加载工作流配置
  async loadWorkflow(configPath: string): Promise<WorkflowConfig> {
    const configData = await invoke('load_workflow_config', { configPath });
    const config = JSON.parse(configData as string) as WorkflowConfig;
    this.workflows.set(config.name, config);
    return config;
  }
  
  // 执行工作流
  async executeWorkflow(workflowName: string, params?: any): Promise<string> {
    const config = this.workflows.get(workflowName);
    if (!config) {
      throw new Error(`工作流 ${workflowName} 未找到`);
    }
    
    const executionId = `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const execution: WorkflowExecution = {
      id: executionId,
      workflowName,
      status: 'running',
      startTime: new Date(),
      currentStep: 0,
      context: params || {},
      stepResults: []
    };
    
    this.executions.set(executionId, execution);
    
    try {
      // 记录工作流开始
      await invoke('log_workflow_execution', {
        executionId,
        workflowName,
        status: 'started',
        timestamp: execution.startTime.toISOString()
      });
      
      // 执行步骤
      for (let i = 0; i < config.steps.length; i++) {
        execution.currentStep = i;
        const step = config.steps[i];
        
        try {
          const stepResult = await this.executeStep(step, execution);
          execution.stepResults.push({
            stepId: step.id,
            status: 'completed',
            result: stepResult,
            timestamp: new Date().toISOString()
          });
          
          // 更新上下文
          execution.context[step.id] = stepResult;
          
        } catch (error) {
          execution.stepResults.push({
            stepId: step.id,
            status: 'failed',
            error: error.message,
            timestamp: new Date().toISOString()
          });
          throw error;
        }
      }
      
      execution.status = 'completed';
      execution.endTime = new Date();
      
      await invoke('log_workflow_execution', {
        executionId,
        status: 'completed',
        timestamp: execution.endTime.toISOString()
      });
      
    } catch (error) {
      execution.status = 'failed';
      execution.error = error.message;
      execution.endTime = new Date();
      
      await invoke('log_workflow_execution', {
        executionId,
        status: 'failed',
        error: error.message,
        timestamp: execution.endTime.toISOString()
      });
      
      throw error;
    }
    
    return executionId;
  }
  
  // 执行单个步骤
  private async executeStep(step: WorkflowStep, execution: WorkflowExecution): Promise<any> {
    console.log(`执行步骤: ${step.name} (${step.type})`);
    
    switch (step.type) {
      case 'scraper':
        return await this.executeScraperStep(step, execution);
      case 'analyzer':
        return await this.executeAnalyzerStep(step, execution);
      case 'price_checker':
        return await this.executePriceCheckerStep(step, execution);
      case 'publisher':
        return await this.executePublisherStep(step, execution);
      default:
        throw new Error(`未知步骤类型: ${step.type}`);
    }
  }
  
  // 执行爬虫步骤
  private async executeScraperStep(step: WorkflowStep, execution: WorkflowExecution): Promise<any> {
    const config = step.config as ScraperStepConfig;
    
    // 使用前端爬虫服务
    const crawler = new FrontendCrawleeScrapingSession({
      headless: true,
      antiDetection: {},
      maxConcurrency: 3,
      requestDelay: 1000
    });
    
    const urls = this.generateScraperUrls(config);
    await crawler.start(urls);
    
    // 获取爬取结果
    const scrapedData = await invoke('get_scraped_data_by_execution', { 
      executionId: execution.id 
    });
    
    return scrapedData;
  }
  
  // 执行AI分析步骤
  private async executeAnalyzerStep(step: WorkflowStep, execution: WorkflowExecution): Promise<any> {
    const config = step.config as AnalyzerStepConfig;
    const products = execution.context[step.id.replace('_analysis', '_collection')] || [];
    
    // 使用前端AI服务
    const aiService = new FrontendFastGPTService({
      apiKey: process.env.FASTGPT_API_KEY || '',
      baseUrl: process.env.FASTGPT_BASE_URL || ''
    });
    
    const analyses = await aiService.batchAnalyzeProducts(products);
    
    // 根据配置筛选Top N产品
    const topProducts = analyses
      .sort((a, b) => (b.confidence || 0) - (a.confidence || 0))
      .slice(0, config.topN || 50);
    
    return topProducts;
  }
  
  // 执行比价步骤
  private async executePriceCheckerStep(step: WorkflowStep, execution: WorkflowExecution): Promise<any> {
    const config = step.config as PriceCheckerStepConfig;
    const products = execution.context[step.id.replace('_comparison', '_analysis')] || [];
    
    // 通过Tauri API执行1688比价
    const priceComparisons = await invoke('execute_price_comparison', {
      products,
      platform: config.platform,
      config
    });
    
    return priceComparisons;
  }
  
  // 执行发布步骤
  private async executePublisherStep(step: WorkflowStep, execution: WorkflowExecution): Promise<any> {
    const config = step.config as PublisherStepConfig;
    const products = execution.context[step.id.replace('_publish', '_comparison')] || [];
    
    // 通过Tauri API执行自动发布
    const publishResults = await invoke('execute_auto_publish', {
      products,
      platforms: config.platforms,
      config
    });
    
    return publishResults;
  }
  
  // 生成爬虫URL
  private generateScraperUrls(config: ScraperStepConfig): string[] {
    const urls: string[] = [];
    
    for (const plugin of config.plugins) {
      for (const category of config.categories) {
        switch (plugin) {
          case 'taobao':
            urls.push(`https://s.taobao.com/search?q=${encodeURIComponent(category)}`);
            break;
          case 'jd':
            urls.push(`https://search.jd.com/Search?keyword=${encodeURIComponent(category)}`);
            break;
          case 'pdd':
            urls.push(`https://mobile.yangkeduo.com/search_result.html?search_key=${encodeURIComponent(category)}`);
            break;
        }
      }
    }
    
    return urls;
  }
  
  // 获取执行状态
  getExecutionStatus(executionId: string): WorkflowExecution | null {
    return this.executions.get(executionId) || null;
  }
  
  // 停止执行
  async stopExecution(executionId: string): Promise<void> {
    const execution = this.executions.get(executionId);
    if (execution && execution.status === 'running') {
      execution.status = 'stopped';
      execution.endTime = new Date();
      
      await invoke('log_workflow_execution', {
        executionId,
        status: 'stopped',
        timestamp: execution.endTime.toISOString()
      });
    }
  }
}

// 工作流配置接口
interface WorkflowConfig {
  name: string;
  version: string;
  steps: WorkflowStep[];
  schedule?: {
    type: string;
    expression: string;
    timezone: string;
  };
}

interface WorkflowStep {
  id: string;
  name: string;
  type: 'scraper' | 'analyzer' | 'price_checker' | 'publisher';
  config: any;
  next?: string;
}

interface WorkflowExecution {
  id: string;
  workflowName: string;
  status: 'running' | 'completed' | 'failed' | 'stopped';
  startTime: Date;
  endTime?: Date;
  currentStep: number;
  context: any;
  stepResults: StepResult[];
  error?: string;
}

interface StepResult {
  stepId: string;
  status: 'completed' | 'failed';
  result?: any;
  error?: string;
  timestamp: string;
}

// 步骤配置接口
interface ScraperStepConfig {
  plugins: string[];
  categories: string[];
  maxProducts: number;
  filters: {
    minSales: number;
    minRating: number;
  };
}

interface AnalyzerStepConfig {
  plugin: string;
  criteria: {
    salesTrend: number;
    profitMargin: number;
    competition: number;
    marketDemand: number;
  };
  topN: number;
}

interface PriceCheckerStepConfig {
  platform: string;
  maxPriceRatio: number;
  minProfitMargin: number;
  qualityThreshold: number;
}

interface PublisherStepConfig {
  platforms: string[];
  optimization: {
    titleOptimization: boolean;
    descriptionEnhancement: boolean;
    imageProcessing: boolean;
    seoOptimization: boolean;
  };
  pricing: {
    strategy: string;
    markup: number;
  };
}
```

**工作流配置示例**:
```json
{
  "name": "电商自动化默认流程",
  "version": "1.0.0",
  "steps": [
    {
      "id": "data_collection",
      "name": "数据采集",
      "type": "scraper",
      "config": {
        "plugins": ["taobao", "jd", "pdd"],
        "categories": ["electronics", "fashion", "home"],
        "maxProducts": 1000,
        "filters": {
          "minSales": 100,
          "minRating": 4.0
        }
      },
      "next": "ai_analysis"
    },
    {
      "id": "ai_analysis",
      "name": "AI爆品分析",
      "type": "analyzer",
      "config": {
        "plugin": "fastgpt-analyzer",
        "criteria": {
          "salesTrend": 0.3,
          "profitMargin": 0.3,
          "competition": 0.2,
          "marketDemand": 0.2
        },
        "topN": 50
      },
      "next": "price_comparison"
    },
    {
      "id": "price_comparison",
      "name": "1688比价",
      "type": "price_checker",
      "config": {
        "platform": "1688",
        "maxPriceRatio": 0.6,
        "minProfitMargin": 0.3,
        "qualityThreshold": 4.0
      },
      "next": "auto_publish"
    },
    {
      "id": "auto_publish",
      "name": "自动上品",
      "type": "publisher",
      "config": {
        "platforms": ["shopify", "woocommerce"],
        "optimization": {
          "titleOptimization": true,
          "descriptionEnhancement": true,
          "imageProcessing": true,
          "seoOptimization": true
        },
        "pricing": {
          "strategy": "competitive",
          "markup": 1.5
        }
      }
    }
  ],
  "schedule": {
    "type": "cron",
    "expression": "0 2 * * *",
    "timezone": "Asia/Shanghai"
  }
}
```

## 🗄️ 数据库设计

### 核心数据表

**商品表 (products)**:
- id: 商品唯一标识
- title: 商品标题
- description: 商品描述
- price: 当前价格
- original_price: 原价
- images: 商品图片JSON
- specifications: 规格参数JSON
- source_platform: 来源平台
- source_url: 来源链接
- sales_count: 销量
- rating: 评分
- review_count: 评论数
- status: 状态
- created_at/updated_at: 时间戳

**AI分析结果表 (ai_analysis)**:
- id: 分析记录ID
- product_id: 关联商品ID
- analysis_type: 分析类型
- score: 分析得分
- insights: 分析洞察JSON
- recommendations: 推荐建议JSON
- created_at: 创建时间

**比价结果表 (price_comparisons)**:
- id: 比价记录ID
- product_id: 关联商品ID
- supplier_platform: 供应商平台
- supplier_price: 供应商价格
- supplier_url: 供应商链接
- profit_margin: 利润率
- quality_score: 质量评分
- created_at: 创建时间

**发布记录表 (publish_records)**:
- id: 发布记录ID
- product_id: 关联商品ID
- target_platform: 目标平台
- platform_product_id: 平台商品ID
- publish_status: 发布状态
- publish_data: 发布数据JSON
- error_message: 错误信息
- created_at: 创建时间

## 🔄 核心业务流程

### 流程1：数据采集
1. **平台选择**: 选择要抓取的电商平台
2. **关键词设置**: 设定搜索关键词或分类
3. **过滤条件**: 设置销量、评分、价格等过滤条件
4. **数据抓取**: 执行爬虫任务
5. **数据清洗**: 标准化商品信息
6. **数据存储**: 保存到数据库

### 流程2：AI分析
1. **数据预处理**: 整理商品数据
2. **FastGPT调用**: 发送分析请求
3. **多维度评估**: 销量、利润、竞争度分析
4. **爆品识别**: 筛选出潜力商品
5. **排序推荐**: 按潜力值排序
6. **结果存储**: 保存分析结果

### 流程3：1688比价
1. **商品匹配**: 在1688搜索相似商品
2. **价格对比**: 计算成本和利润率
3. **供应商评估**: 评估供应商质量
4. **最优选择**: 选择最佳供应商
5. **成本计算**: 包含物流等成本
6. **利润分析**: 计算预期利润

### 流程4：自动上品
1. **平台选择**: 选择目标销售平台
2. **信息优化**: 优化标题、描述等
3. **图片处理**: 压缩、水印、尺寸调整
4. **价格策略**: 应用定价策略
5. **商品发布**: 自动上传到平台
6. **状态监控**: 监控发布状态

## 🛠️ 辅助系统

### 任务调度系统
- 定时任务管理
- 任务队列处理
- 并发控制
- 失败重试机制
- 任务优先级管理

### 监控报警系统
- 系统性能监控
- 任务执行监控
- 异常报警
- 数据质量监控
- 资源使用监控

### 配置管理系统
- 全局配置管理
- 插件配置管理
- 环境配置切换
- 配置版本控制
- 配置热更新

### 日志系统
- 结构化日志记录
- 日志分级管理
- 日志搜索和过滤
- 日志归档和清理
- 性能日志分析

## 🚀 PC客户端开发计划

### 阶段1：基础架构搭建 (4-6周)
- [ ] Electron项目初始化和开发环境搭建
- [ ] 主进程和渲染进程基础架构
- [ ] IPC通信机制实现
- [ ] 本地SQLite数据库设计和实现
- [ ] 基础UI框架搭建(React + shadcn/ui)
- [ ] 插件管理系统架构设计
- [ ] 基础Crawlee爬虫引擎实现

### 阶段2：核心业务功能 (6-8周)
- [ ] 主要电商平台Crawlee爬虫插件开发
  - [ ] 淘宝Crawlee爬虫插件(会话池管理、自动重试)
  - [ ] 京东Crawlee爬虫插件(代理轮换、智能队列)
  - [ ] 拼多多Crawlee爬虫插件(反检测策略、失败处理)
- [ ] FastGPT AI分析模块集成
- [ ] 1688比价模块实现
- [ ] 基础上品插件开发(Shopify、WooCommerce)
- [ ] 轻量级工作流引擎实现
- [ ] 任务调度和队列管理

### 阶段3：桌面端UI和交互 (4-6周)
- [ ] 主界面设计和实现
  - [ ] 任务管理界面
  - [ ] 商品管理界面
  - [ ] 数据分析界面
  - [ ] 系统设置界面
- [ ] 系统托盘和菜单栏功能
- [ ] 窗口管理和状态保存
- [ ] 系统通知和提醒功能
- [ ] 全局快捷键支持
- [ ] 拖拽文件导入功能

### 阶段4：性能优化和测试 (3-4周)
- [ ] 性能优化
  - [ ] 内存使用优化
  - [ ] 大数据列表虚拟滚动
  - [ ] 懒加载和缓存机制
- [ ] 全面测试
  - [ ] 单元测试
  - [ ] 集成测试
  - [ ] 端到端测试
  - [ ] 多平台兼容性测试
- [ ] 错误处理和日志系统完善
- [ ] 用户体验优化

### 阶段5：打包部署和发布 (2-3周)
- [ ] 多平台打包配置
  - [ ] Windows安装程序
  - [ ] macOS应用程序包
  - [ ] Linux AppImage/deb包
- [ ] 代码签名和安全认证
- [ ] 自动更新机制实现
- [ ] 应用商店上架准备
- [ ] 用户文档和帮助系统
- [ ] Beta版本发布和用户反馈收集

### 阶段6：扩展功能和维护 (持续)
- [ ] 更多电商平台插件开发
- [ ] 高级AI分析功能
- [ ] 数据导入导出功能
- [ ] 多语言支持
- [ ] 主题和个性化设置
- [ ] 插件市场和社区功能
- [ ] 企业版功能开发

## 🎯 核心特性

### 1. 插件热插拔
- 支持运行时加载/卸载插件
- 插件版本管理和更新
- 插件配置动态修改

### 2. 智能工作流
- 可视化工作流编辑器
- 条件分支和循环支持
- 错误处理和重试机制

### 3. AI驱动决策
- FastGPT深度分析
- 市场趋势预测
- 智能定价策略

### 4. 多平台支持
- 统一的数据格式
- 平台特定的适配器
- 批量操作支持

### 5. 监控和报告
- 实时任务监控
- 性能指标统计
- 自动报告生成

## 📈 PC客户端预期效果

### 业务价值
- **效率提升**: 电商运营自动化程度达到90%以上
- **成本降低**: 人工运营成本降低70%
- **准确性**: AI爆品分析准确率达到85%以上
- **易用性**: 零技术门槛，普通用户即可上手
- **本地化**: 数据完全本地存储，保护商业机密
- **稳定性**: 7x24小时稳定运行，支持后台挂机

### 技术指标
- **性能表现**: 支持1000+商品同时处理分析
- **响应速度**: 界面响应时间<200ms，操作流畅
- **内存占用**: 正常运行内存占用<500MB
- **启动速度**: 应用启动时间<3秒
- **稳定性**: 连续运行30天无崩溃
- **兼容性**: 支持Windows 10+、macOS 10.15+、Ubuntu 18.04+

### 用户体验
- **界面友好**: 现代化UI设计，符合桌面应用习惯
- **操作简单**: 一键启动任务，可视化配置
- **实时反馈**: 任务进度实时显示，状态一目了然
- **智能提醒**: 系统通知及时提醒重要事件
- **数据安全**: 本地加密存储，支持数据备份恢复
- **离线可用**: 核心功能支持离线使用

## 🚀 三层分离架构优势

### 架构优势
- **业务集中**: 所有爬虫、AI分析、插件功能集中在侧车进程，实现业务逻辑统一管理
- **职责分离**: 前端专注UI渲染，Rust后端专注调度管理，Node.js侧车专注业务处理
- **进程隔离**: 业务逻辑独立运行，不影响主应用UI响应性和稳定性
- **热插拔支持**: 支持插件和平台适配器的动态加载、更新和卸载
- **负载均衡**: 支持多侧车进程实例，根据负载自动分配任务
- **故障隔离**: 单个侧车进程故障不影响其他进程和主应用

### 技术优势
- **资源管理**: 可独立控制每个侧车进程的内存和CPU使用
- **并发处理**: 多进程并行处理，充分利用多核CPU性能
- **故障恢复**: 侧车进程崩溃自动重启，支持故障转移和数据恢复
- **跨平台兼容**: 打包为自包含二进制，无需用户安装Node.js环境
- **性能优化**: Node.js异步I/O专门处理爬虫任务，Rust调度器高效管理
- **开发效率**: 三层架构职责清晰，便于团队协作和模块化开发

### 部署优势
- **一键部署**: 侧车二进制文件随主应用一起打包分发
- **版本同步**: 侧车进程版本与主应用版本保持同步
- **安全隔离**: 侧车进程运行在受限环境中，提高整体安全性
- **易于维护**: 独立的侧车进程便于单独更新、调试和监控
- **扩展性强**: 可以轻松添加新的侧车进程处理不同业务模块
- **配置灵活**: 支持动态配置侧车进程数量和资源分配

### 业务场景
- **批量爬取**: 多个侧车进程并行处理大量爬取任务，提高处理效率
- **平台隔离**: 不同电商平台使用独立的侧车进程，避免相互影响
- **AI分析**: 专门的侧车进程处理AI数据分析，不影响爬虫任务
- **插件管理**: 动态加载和管理各种功能插件，支持第三方扩展
- **资源控制**: 根据系统资源和任务负载动态调整侧车进程数量
- **开发调试**: 可以独立调试和测试侧车进程功能，不影响主应用

## 🔒 风险控制与应对

### 技术风险
- **反爬虫机制**: 各大电商平台不断升级反爬虫策略
- **API限流封禁**: 频繁请求可能导致IP或账号被封
- **数据质量**: 网页结构变化导致数据解析失败
- **系统稳定性**: 多进程架构的复杂性增加故障风险
- **侧车进程管理**: 进程间通信和状态同步的复杂性
- **资源消耗**: 多侧车进程可能导致系统资源过度消耗

### 业务风险
- **平台政策变化**: 电商平台服务条款和爬虫政策调整
- **市场竞争加剧**: 同类产品竞争激烈，技术门槛提高
- **法律合规要求**: 数据爬取的法律边界和合规性要求
- **数据安全保护**: 用户数据和商业数据的安全存储和传输
- **依赖风险**: 对第三方库和服务的依赖可能带来供应链风险

### 架构风险
- **进程通信**: 前端、后端、侧车进程间的通信可能出现故障
- **负载均衡**: 多侧车进程的负载分配和任务调度复杂性
- **故障传播**: 单个组件故障可能影响整个系统运行
- **版本同步**: 三层架构的版本更新和兼容性管理
- **配置管理**: 多进程环境下的配置同步和一致性

### 应对措施

#### 技术应对
- **多重备份机制**: 数据多重备份，支持快速恢复
- **灵活的插件架构**: 支持热插拔，快速适应平台变化
- **完善的监控体系**: 实时监控各层组件状态和性能
- **智能重试机制**: 自动检测失败并采用不同策略重试
- **资源限制**: 动态调整侧车进程数量，防止资源过度消耗
- **健康检查**: 定期检查各组件健康状态，及时发现问题

#### 业务应对
- **合规性审查**: 定期审查爬虫行为的法律合规性
- **多平台策略**: 分散风险，不依赖单一平台
- **数据加密**: 敏感数据加密存储和传输
- **用户协议**: 明确用户责任和使用边界
- **定期风险评估**: 建立风险评估机制，及时调整策略

#### 架构应对
- **故障隔离**: 组件间故障隔离，防止故障传播
- **优雅降级**: 部分功能故障时，保证核心功能正常运行
- **版本管理**: 建立完善的版本管理和回滚机制
- **配置中心**: 统一配置管理，确保配置一致性
- **自动化测试**: 完善的自动化测试覆盖各层组件

---

**文档版本**: v1.0  
**最后更新**: 2024年12月  
**维护人员**: 开发团队  
**审核状态**: 待审核