# 电商AI自动化平台 - 技术架构设计

## 🏗️ 系统架构概览

### 分层架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                     表现层 (Presentation Layer)              │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   Web Console   │  │   Mobile App    │  │   API Gateway   │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                     业务层 (Business Layer)                  │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │ Workflow Engine │  │  Task Scheduler │  │ Plugin Manager  │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                     服务层 (Service Layer)                   │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │ Scraper Service │  │   AI Service    │  │ Publisher Svc   │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                     数据层 (Data Layer)                      │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   PostgreSQL    │  │      Redis      │  │   File Storage  │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

## 🔧 技术栈选型

### 后端技术栈

| 组件 | 技术选型 | 版本 | 说明 |
|------|----------|------|------|
| 运行时 | Node.js | 18+ | 高性能JavaScript运行时 |
| Web框架 | Express.js | 4.18+ | 轻量级Web框架 |
| 爬虫引擎 | Playwright | 1.40+ | 现代化浏览器自动化 |
| 数据库 | PostgreSQL | 14+ | 关系型数据库 |
| 缓存 | Redis | 7+ | 内存数据库 |
| 消息队列 | Bull Queue | 4+ | Redis-based队列 |
| ORM | Prisma | 5+ | 现代化数据库工具 |
| 日志 | Winston | 3+ | 日志管理 |
| 测试 | Jest | 29+ | 测试框架 |

### 前端技术栈

| 组件 | 技术选型 | 版本 | 说明 |
|------|----------|------|------|
| 框架 | React | 18+ | 用户界面库 |
| 状态管理 | Zustand | 4+ | 轻量级状态管理 |
| 路由 | React Router | 6+ | 客户端路由 |
| UI组件 | Ant Design | 5+ | 企业级UI组件库 |
| 图表 | ECharts | 5+ | 数据可视化 |
| 构建工具 | Vite | 5+ | 现代化构建工具 |
| CSS框架 | Tailwind CSS | 3+ | 实用优先的CSS框架 |

### 基础设施

| 组件 | 技术选型 | 说明 |
|------|----------|------|
| 容器化 | Docker | 应用容器化 |
| 编排 | Docker Compose | 本地开发环境 |
| 反向代理 | Nginx | 负载均衡和静态文件服务 |
| 监控 | Prometheus + Grafana | 系统监控和可视化 |
| 日志收集 | ELK Stack | 日志聚合和分析 |

## 🔌 插件系统架构

### 插件生命周期管理

```javascript
class PluginManager {
  constructor() {
    this.plugins = new Map();
    this.hooks = new Map();
    this.eventBus = new EventEmitter();
  }

  // 插件注册
  async register(pluginConfig) {
    const plugin = await this.loadPlugin(pluginConfig);
    await plugin.initialize();
    this.plugins.set(plugin.name, plugin);
    this.registerHooks(plugin);
    this.eventBus.emit('plugin:registered', plugin);
  }

  // 插件卸载
  async unregister(pluginName) {
    const plugin = this.plugins.get(pluginName);
    if (plugin) {
      await plugin.destroy();
      this.plugins.delete(pluginName);
      this.unregisterHooks(plugin);
      this.eventBus.emit('plugin:unregistered', plugin);
    }
  }

  // 执行钩子
  async executeHook(hookName, context) {
    const hooks = this.hooks.get(hookName) || [];
    const results = [];
    
    for (const hook of hooks) {
      try {
        const result = await hook.execute(context);
        results.push(result);
      } catch (error) {
        console.error(`Hook ${hookName} execution failed:`, error);
      }
    }
    
    return results;
  }
}
```

### 插件接口定义

```typescript
// 爬虫插件接口
interface IScraperPlugin {
  name: string;
  version: string;
  supportedDomains: string[];
  
  initialize(): Promise<void>;
  destroy(): Promise<void>;
  
  scrapeProduct(url: string): Promise<Product>;
  scrapeCategory(categoryUrl: string, options?: ScrapeOptions): Promise<Product[]>;
  searchProducts(keyword: string, options?: SearchOptions): Promise<Product[]>;
  
  validateProduct(product: Product): Promise<boolean>;
  login?(credentials: LoginCredentials): Promise<boolean>;
}

// 发布插件接口
interface IPublisherPlugin {
  name: string;
  version: string;
  platform: string;
  
  initialize(): Promise<void>;
  destroy(): Promise<void>;
  
  authenticate(): Promise<boolean>;
  publishProduct(product: Product): Promise<PublishResult>;
  updateProduct(productId: string, product: Product): Promise<UpdateResult>;
  deleteProduct(productId: string): Promise<DeleteResult>;
  
  getProductStatus(productId: string): Promise<ProductStatus>;
  validateProductData(product: Product): Promise<ValidationResult>;
}

// AI分析插件接口
interface IAnalyzerPlugin {
  name: string;
  version: string;
  
  initialize(): Promise<void>;
  destroy(): Promise<void>;
  
  analyzeProducts(products: Product[]): Promise<AnalysisResult[]>;
  predictTrend(product: Product): Promise<TrendPrediction>;
  optimizeProduct(product: Product): Promise<OptimizationSuggestion>;
  
  calculateScore(product: Product, criteria: AnalysisCriteria): Promise<number>;
}
```

## 🔄 工作流引擎设计

### 工作流执行引擎

```javascript
class WorkflowEngine {
  constructor(pluginManager, taskScheduler) {
    this.pluginManager = pluginManager;
    this.taskScheduler = taskScheduler;
    this.executionContext = new Map();
  }

  async executeWorkflow(workflowConfig, initialData = {}) {
    const execution = {
      id: generateId(),
      workflowId: workflowConfig.id,
      status: 'running',
      startTime: new Date(),
      currentStep: null,
      data: initialData,
      results: {},
      errors: []
    };

    this.executionContext.set(execution.id, execution);

    try {
      for (const step of workflowConfig.steps) {
        execution.currentStep = step.id;
        
        // 检查执行条件
        if (step.condition && !this.evaluateCondition(step.condition, execution.data)) {
          continue;
        }

        // 执行步骤
        const result = await this.executeStep(step, execution.data);
        execution.results[step.id] = result;
        
        // 更新执行数据
        if (step.outputMapping) {
          this.mapOutput(step.outputMapping, result, execution.data);
        }

        // 检查是否需要跳转
        if (step.next) {
          const nextStepId = this.resolveNextStep(step.next, result);
          if (nextStepId === 'end') break;
        }
      }

      execution.status = 'completed';
      execution.endTime = new Date();
      
    } catch (error) {
      execution.status = 'failed';
      execution.errors.push(error.message);
      execution.endTime = new Date();
      
      // 执行错误处理
      await this.handleWorkflowError(execution, error);
    }

    return execution;
  }

  async executeStep(step, data) {
    const handler = this.getStepHandler(step.type);
    if (!handler) {
      throw new Error(`Unknown step type: ${step.type}`);
    }

    const context = {
      stepId: step.id,
      config: step.config,
      data: data,
      pluginManager: this.pluginManager
    };

    return await handler.execute(context);
  }

  getStepHandler(stepType) {
    const handlers = {
      'scraper': new ScraperStepHandler(),
      'analyzer': new AnalyzerStepHandler(),
      'price_checker': new PriceCheckerStepHandler(),
      'publisher': new PublisherStepHandler(),
      'condition': new ConditionStepHandler(),
      'parallel': new ParallelStepHandler()
    };

    return handlers[stepType];
  }
}
```

### 步骤处理器实现

```javascript
class ScraperStepHandler {
  async execute(context) {
    const { config, data, pluginManager } = context;
    const results = [];

    for (const pluginName of config.plugins) {
      const plugin = pluginManager.getPlugin(pluginName);
      if (!plugin) continue;

      try {
        let products = [];
        
        if (config.keywords) {
          for (const keyword of config.keywords) {
            const searchResults = await plugin.searchProducts(keyword, config.searchOptions);
            products.push(...searchResults);
          }
        }

        if (config.categories) {
          for (const categoryUrl of config.categories) {
            const categoryResults = await plugin.scrapeCategory(categoryUrl, config.scrapeOptions);
            products.push(...categoryResults);
          }
        }

        // 应用过滤器
        if (config.filters) {
          products = this.applyFilters(products, config.filters);
        }

        results.push({
          plugin: pluginName,
          products: products,
          count: products.length
        });

      } catch (error) {
        console.error(`Scraper plugin ${pluginName} failed:`, error);
        results.push({
          plugin: pluginName,
          error: error.message,
          products: [],
          count: 0
        });
      }
    }

    return {
      totalProducts: results.reduce((sum, r) => sum + r.count, 0),
      results: results,
      products: results.flatMap(r => r.products)
    };
  }

  applyFilters(products, filters) {
    return products.filter(product => {
      if (filters.minSales && product.salesCount < filters.minSales) return false;
      if (filters.minRating && product.rating < filters.minRating) return false;
      if (filters.maxPrice && product.price > filters.maxPrice) return false;
      if (filters.minPrice && product.price < filters.minPrice) return false;
      return true;
    });
  }
}

class AnalyzerStepHandler {
  async execute(context) {
    const { config, data, pluginManager } = context;
    const products = data.products || [];
    
    if (products.length === 0) {
      return { analyzedProducts: [], topProducts: [] };
    }

    const analyzerPlugin = pluginManager.getPlugin(config.plugin);
    if (!analyzerPlugin) {
      throw new Error(`Analyzer plugin ${config.plugin} not found`);
    }

    // 执行AI分析
    const analysisResults = await analyzerPlugin.analyzeProducts(products);
    
    // 计算综合得分
    const scoredProducts = products.map((product, index) => {
      const analysis = analysisResults[index];
      const score = this.calculateCompositeScore(analysis, config.criteria);
      
      return {
        ...product,
        analysis: analysis,
        score: score
      };
    });

    // 排序并选择Top N
    const topProducts = scoredProducts
      .sort((a, b) => b.score - a.score)
      .slice(0, config.topN || 50);

    return {
      analyzedProducts: scoredProducts,
      topProducts: topProducts,
      totalAnalyzed: products.length,
      averageScore: scoredProducts.reduce((sum, p) => sum + p.score, 0) / scoredProducts.length
    };
  }

  calculateCompositeScore(analysis, criteria) {
    let score = 0;
    
    if (criteria.salesTrend) {
      score += analysis.salesTrendScore * criteria.salesTrend;
    }
    
    if (criteria.profitMargin) {
      score += analysis.profitMarginScore * criteria.profitMargin;
    }
    
    if (criteria.competition) {
      score += analysis.competitionScore * criteria.competition;
    }
    
    if (criteria.marketDemand) {
      score += analysis.marketDemandScore * criteria.marketDemand;
    }

    return Math.min(Math.max(score, 0), 100); // 限制在0-100之间
  }
}
```

## 🗄️ 数据架构设计

### 数据库Schema设计

```sql
-- 商品表
CREATE TABLE products (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(500) NOT NULL,
    description TEXT,
    price DECIMAL(12,2),
    original_price DECIMAL(12,2),
    currency VARCHAR(3) DEFAULT 'CNY',
    images JSONB,
    specifications JSONB,
    source_platform VARCHAR(50) NOT NULL,
    source_url VARCHAR(1000),
    source_id VARCHAR(100),
    category_id UUID REFERENCES categories(id),
    brand VARCHAR(100),
    sales_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    review_count INTEGER DEFAULT 0,
    tags TEXT[],
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 索引
    INDEX idx_products_source (source_platform, source_id),
    INDEX idx_products_category (category_id),
    INDEX idx_products_status (status),
    INDEX idx_products_created (created_at),
    INDEX idx_products_price (price),
    INDEX idx_products_rating (rating)
);

-- 分类表
CREATE TABLE categories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(200) NOT NULL,
    slug VARCHAR(200) UNIQUE,
    parent_id UUID REFERENCES categories(id),
    level INTEGER DEFAULT 0,
    path VARCHAR(500), -- 分类路径，如 "/electronics/phones/smartphones"
    description TEXT,
    image_url VARCHAR(500),
    sort_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_categories_parent (parent_id),
    INDEX idx_categories_path (path),
    INDEX idx_categories_slug (slug)
);

-- AI分析结果表
CREATE TABLE ai_analysis (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    product_id UUID REFERENCES products(id) ON DELETE CASCADE,
    analyzer_plugin VARCHAR(50) NOT NULL,
    analysis_type VARCHAR(50) NOT NULL,
    score DECIMAL(5,2),
    confidence DECIMAL(3,2), -- 置信度
    insights JSONB, -- 分析洞察
    recommendations JSONB, -- 推荐建议
    market_trend JSONB, -- 市场趋势
    competition_analysis JSONB, -- 竞争分析
    profit_analysis JSONB, -- 利润分析
    risk_assessment JSONB, -- 风险评估
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_ai_analysis_product (product_id),
    INDEX idx_ai_analysis_type (analysis_type),
    INDEX idx_ai_analysis_score (score),
    INDEX idx_ai_analysis_created (created_at)
);

-- 价格比较表
CREATE TABLE price_comparisons (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    product_id UUID REFERENCES products(id) ON DELETE CASCADE,
    supplier_platform VARCHAR(50) NOT NULL,
    supplier_name VARCHAR(200),
    supplier_id VARCHAR(100),
    supplier_url VARCHAR(1000),
    supplier_price DECIMAL(12,2) NOT NULL,
    shipping_cost DECIMAL(12,2) DEFAULT 0,
    total_cost DECIMAL(12,2) GENERATED ALWAYS AS (supplier_price + shipping_cost) STORED,
    profit_margin DECIMAL(5,2),
    quality_score DECIMAL(3,2),
    delivery_time INTEGER, -- 发货时间（天）
    minimum_order_quantity INTEGER DEFAULT 1,
    supplier_rating DECIMAL(3,2),
    supplier_reviews INTEGER DEFAULT 0,
    is_recommended BOOLEAN DEFAULT false,
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_price_comparisons_product (product_id),
    INDEX idx_price_comparisons_platform (supplier_platform),
    INDEX idx_price_comparisons_price (supplier_price),
    INDEX idx_price_comparisons_margin (profit_margin),
    INDEX idx_price_comparisons_recommended (is_recommended)
);

-- 发布记录表
CREATE TABLE publish_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    product_id UUID REFERENCES products(id) ON DELETE CASCADE,
    target_platform VARCHAR(50) NOT NULL,
    platform_product_id VARCHAR(100),
    platform_url VARCHAR(1000),
    publish_status VARCHAR(20) DEFAULT 'pending', -- pending, published, failed, updated, deleted
    publish_data JSONB, -- 发布时的商品数据
    optimization_applied JSONB, -- 应用的优化
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    last_sync_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_publish_records_product (product_id),
    INDEX idx_publish_records_platform (target_platform),
    INDEX idx_publish_records_status (publish_status),
    INDEX idx_publish_records_platform_id (target_platform, platform_product_id)
);

-- 工作流执行记录表
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id VARCHAR(100) NOT NULL,
    workflow_name VARCHAR(200),
    status VARCHAR(20) DEFAULT 'running', -- running, completed, failed, cancelled
    trigger_type VARCHAR(50), -- manual, scheduled, webhook
    trigger_data JSONB,
    input_data JSONB,
    output_data JSONB,
    current_step VARCHAR(100),
    completed_steps TEXT[],
    failed_steps TEXT[],
    error_message TEXT,
    execution_time_ms INTEGER,
    started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    
    INDEX idx_workflow_executions_workflow (workflow_id),
    INDEX idx_workflow_executions_status (status),
    INDEX idx_workflow_executions_started (started_at)
);

-- 任务队列表
CREATE TABLE task_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_type VARCHAR(50) NOT NULL,
    task_name VARCHAR(200),
    priority INTEGER DEFAULT 0, -- 优先级，数字越大优先级越高
    status VARCHAR(20) DEFAULT 'pending', -- pending, processing, completed, failed, cancelled
    payload JSONB NOT NULL,
    result JSONB,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    max_retries INTEGER DEFAULT 3,
    scheduled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_task_queue_status_priority (status, priority DESC),
    INDEX idx_task_queue_type (task_type),
    INDEX idx_task_queue_scheduled (scheduled_at)
);

-- 系统配置表
CREATE TABLE system_configs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    config_key VARCHAR(100) UNIQUE NOT NULL,
    config_value JSONB NOT NULL,
    description TEXT,
    is_encrypted BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_system_configs_key (config_key)
);

-- 插件配置表
CREATE TABLE plugin_configs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    plugin_name VARCHAR(100) NOT NULL,
    plugin_type VARCHAR(50) NOT NULL, -- scraper, publisher, analyzer
    version VARCHAR(20),
    config_data JSONB NOT NULL,
    is_enabled BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(plugin_name, plugin_type),
    INDEX idx_plugin_configs_type (plugin_type),
    INDEX idx_plugin_configs_enabled (is_enabled)
);
```

### 缓存策略设计

```javascript
class CacheManager {
  constructor(redisClient) {
    this.redis = redisClient;
    this.defaultTTL = 3600; // 1小时
  }

  // 商品缓存策略
  async cacheProduct(product) {
    const key = `product:${product.id}`;
    await this.redis.setex(key, this.defaultTTL, JSON.stringify(product));
    
    // 按平台缓存
    const platformKey = `products:${product.source_platform}`;
    await this.redis.sadd(platformKey, product.id);
    await this.redis.expire(platformKey, this.defaultTTL);
  }

  // AI分析结果缓存
  async cacheAnalysis(productId, analysis) {
    const key = `analysis:${productId}`;
    await this.redis.setex(key, 7200, JSON.stringify(analysis)); // 2小时
  }

  // 价格比较缓存
  async cachePriceComparison(productId, comparison) {
    const key = `price:${productId}`;
    await this.redis.setex(key, 1800, JSON.stringify(comparison)); // 30分钟
  }

  // 工作流执行状态缓存
  async cacheWorkflowExecution(executionId, execution) {
    const key = `workflow:${executionId}`;
    await this.redis.setex(key, 86400, JSON.stringify(execution)); // 24小时
  }

  // 批量失效缓存
  async invalidateProductCache(productId) {
    const keys = [
      `product:${productId}`,
      `analysis:${productId}`,
      `price:${productId}`
    ];
    
    await this.redis.del(...keys);
  }
}
```

## 🔐 安全架构设计

### 认证和授权

```javascript
class SecurityManager {
  constructor() {
    this.jwtSecret = process.env.JWT_SECRET;
    this.encryptionKey = process.env.ENCRYPTION_KEY;
  }

  // JWT Token生成
  generateToken(user) {
    const payload = {
      userId: user.id,
      email: user.email,
      roles: user.roles,
      permissions: user.permissions
    };
    
    return jwt.sign(payload, this.jwtSecret, {
      expiresIn: '24h',
      issuer: 'ecommerce-ai-platform'
    });
  }

  // 权限验证中间件
  requirePermission(permission) {
    return (req, res, next) => {
      const user = req.user;
      
      if (!user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }
      
      if (!user.permissions.includes(permission)) {
        return res.status(403).json({ error: 'Forbidden' });
      }
      
      next();
    };
  }

  // 敏感数据加密
  encrypt(data) {
    const cipher = crypto.createCipher('aes-256-cbc', this.encryptionKey);
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return encrypted;
  }

  // 敏感数据解密
  decrypt(encryptedData) {
    const decipher = crypto.createDecipher('aes-256-cbc', this.encryptionKey);
    let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
  }

  // API限流
  createRateLimiter(windowMs, max) {
    return rateLimit({
      windowMs: windowMs,
      max: max,
      message: 'Too many requests from this IP',
      standardHeaders: true,
      legacyHeaders: false
    });
  }
}
```

### 数据安全

```javascript
class DataSecurity {
  // 敏感字段加密存储
  static encryptSensitiveFields(data, sensitiveFields) {
    const encrypted = { ...data };
    
    sensitiveFields.forEach(field => {
      if (encrypted[field]) {
        encrypted[field] = SecurityManager.encrypt(encrypted[field]);
      }
    });
    
    return encrypted;
  }

  // 数据脱敏
  static maskSensitiveData(data, maskFields) {
    const masked = { ...data };
    
    maskFields.forEach(field => {
      if (masked[field]) {
        masked[field] = this.maskString(masked[field]);
      }
    });
    
    return masked;
  }

  static maskString(str) {
    if (str.length <= 4) return '***';
    return str.substring(0, 2) + '*'.repeat(str.length - 4) + str.substring(str.length - 2);
  }

  // 输入验证和清理
  static sanitizeInput(input) {
    if (typeof input === 'string') {
      return input.trim().replace(/<script[^>]*>.*?<\/script>/gi, '');
    }
    return input;
  }
}
```

## 📊 监控和日志架构

### 应用监控

```javascript
class MonitoringService {
  constructor() {
    this.metrics = new Map();
    this.alerts = [];
  }

  // 性能指标收集
  recordMetric(name, value, tags = {}) {
    const metric = {
      name,
      value,
      tags,
      timestamp: Date.now()
    };
    
    this.metrics.set(`${name}_${Date.now()}`, metric);
    
    // 发送到Prometheus
    this.sendToPrometheus(metric);
  }

  // 业务指标监控
  trackBusinessMetrics() {
    setInterval(async () => {
      // 爬虫成功率
      const scraperSuccessRate = await this.calculateScraperSuccessRate();
      this.recordMetric('scraper_success_rate', scraperSuccessRate);
      
      // AI分析准确率
      const aiAccuracy = await this.calculateAIAccuracy();
      this.recordMetric('ai_analysis_accuracy', aiAccuracy);
      
      // 发布成功率
      const publishSuccessRate = await this.calculatePublishSuccessRate();
      this.recordMetric('publish_success_rate', publishSuccessRate);
      
      // 系统资源使用率
      const resourceUsage = await this.getResourceUsage();
      this.recordMetric('cpu_usage', resourceUsage.cpu);
      this.recordMetric('memory_usage', resourceUsage.memory);
      
    }, 60000); // 每分钟收集一次
  }

  // 告警检查
  checkAlerts() {
    setInterval(() => {
      this.alerts.forEach(alert => {
        if (this.evaluateAlertCondition(alert)) {
          this.triggerAlert(alert);
        }
      });
    }, 30000); // 每30秒检查一次
  }

  // 健康检查
  async healthCheck() {
    const checks = {
      database: await this.checkDatabase(),
      redis: await this.checkRedis(),
      plugins: await this.checkPlugins(),
      external_apis: await this.checkExternalAPIs()
    };
    
    const isHealthy = Object.values(checks).every(check => check.status === 'ok');
    
    return {
      status: isHealthy ? 'healthy' : 'unhealthy',
      checks,
      timestamp: new Date().toISOString()
    };
  }
}
```

### 结构化日志

```javascript
class Logger {
  constructor() {
    this.winston = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      transports: [
        new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
        new winston.transports.File({ filename: 'logs/combined.log' }),
        new winston.transports.Console({
          format: winston.format.simple()
        })
      ]
    });
  }

  // 业务日志
  logScrapingActivity(activity) {
    this.winston.info('Scraping Activity', {
      type: 'scraping',
      platform: activity.platform,
      productsFound: activity.productsFound,
      duration: activity.duration,
      success: activity.success,
      errors: activity.errors
    });
  }

  logAIAnalysis(analysis) {
    this.winston.info('AI Analysis', {
      type: 'ai_analysis',
      productId: analysis.productId,
      score: analysis.score,
      confidence: analysis.confidence,
      processingTime: analysis.processingTime
    });
  }

  logPublishActivity(activity) {
    this.winston.info('Publish Activity', {
      type: 'publishing',
      platform: activity.platform,
      productId: activity.productId,
      status: activity.status,
      platformProductId: activity.platformProductId
    });
  }

  // 错误日志
  logError(error, context = {}) {
    this.winston.error('Application Error', {
      message: error.message,
      stack: error.stack,
      context: context,
      timestamp: new Date().toISOString()
    });
  }

  // 性能日志
  logPerformance(operation, duration, metadata = {}) {
    this.winston.info('Performance Log', {
      type: 'performance',
      operation: operation,
      duration: duration,
      metadata: metadata
    });
  }
}
```

## 🚀 部署架构

### Docker容器化

```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

# 安装系统依赖
RUN apk add --no-cache \
    chromium \
    nss \
    freetype \
    freetype-dev \
    harfbuzz \
    ca-certificates \
    ttf-freefont

# 设置Puppeteer使用系统Chromium
ENV PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true \
    PUPPETEER_EXECUTABLE_PATH=/usr/bin/chromium-browser

# 复制依赖文件
COPY package*.json ./
RUN npm ci --only=production

# 复制应用代码
COPY . .

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001
USER nextjs

EXPOSE 3000

CMD ["npm", "start"]
```

### Docker Compose配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:password@postgres:5432/ecommerce_ai
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis
    volumes:
      - ./logs:/app/logs
      - ./data:/app/data

  postgres:
    image: postgres:14
    environment:
      - POSTGRES_DB=ecommerce_ai
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app

  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus

  grafana:
    image: grafana/grafana
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana

volumes:
  postgres_data:
  redis_data:
  prometheus_data:
  grafana_data:
```

---

**文档版本**: v1.0  
**最后更新**: 2024年12月  
**维护人员**: 技术团队  
**审核状态**: 待审核